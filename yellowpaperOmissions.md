# 黄皮书拾遗

**4.1** 如果账户状态的代码哈希`codeHash`字段是一个空字符串的Keccak-256哈希，则表示对应的节点表示一个简单账户，有时简称非合约账户。

**4.2** 一个消息调用的交易的`data`数据是一个不限制大小的字节数组，表示消息调用的输入数据。

**6** 所有交易在执行时，都要先通过内部的有效性测试，这些包括：

（1）交易是RLP格式数据，没有多余的后缀字节；

（2）交易的签名是有效的；

（3）交易的随机数是有效的（等于发送者账户的当前随机数）；

（4）燃料上限不小于实际交易过程中用的燃料；

（5）发送者账户的余额至少大于预支付的费用。

**9.2** 存储费用有一个微妙的行为——为最小化存储费用，清除存储的执行费用指令不仅仅免除，而且会返回一些费用；因为初始化的存储费用往往比实际使用的多，在清除存储空间后会有返回费用，这个返回的费用时预先支付的费用中的一部分。
**6.1** 当使用`SSTORE`指令将非0的合约存贮空间置为0时，返回余额会增加。

**8** 消息调用执行框架中有4个特例：这四个是“预编译”合约，地址分别为1、2、3和4，分别是用来执行椭圆曲线公钥恢复函数、SHA2 256位哈希方案、RIPEMD 160位哈希方案和身份函数。

:warning:2018-4-26版本47d2826增加到8个预编译合约。

**11.5** 挖矿和工作量证明

工作量证明（PoW）通过加密安全随机数，来保证要获得要确定满足一定条件的`n`，要花费一定量的计算资源。通过计算给定意义的数值和难度系数来增加区块链安全性。然而因为挖出一个新的区块会附带一些奖励，工作量证明不仅是保证区块链权威的安全函数，而且也是一个健康的分配机制。

出于以上原因，工作量证明函数有两个重要的目标：首先，它应该尽可能的被更多人去接受。对定制特别硬件的需求或者回报，应该被减到最小。这使得分配模型尽可能开放，理想情况是，通过挖矿消耗电力获得以太币，在全世界各个地方都是一样的比例。

第二，应该不允许获得超线性的收益，尤其是在有一个非常高的初始障碍条件下。如果允许这样，一个资金充足的恶意者可以获得引起麻烦的网络挖矿算力，并允许给他们获得超线性的回报（按他们的意愿改变收益分布），并且会弱化网络的安全性。

比特币世界中一个灾难是ASICs。有一些计算硬件仅仅是为了做一个简单的任务而存在。在比特币的案例中，这个任务就是SHA256哈希函数。当ASICs为了工作量证明函数而存在时，两个的目标都会变得危险。因此，一个可抵抗ASIC的工作量证明函数（比如难以在专用硬件上执行，或者在专用硬件执行时并不划算）可以作为众所周知的银弹。

防止ASIC漏洞的两个方向：第一是去让它变成有序列的内存困难，比如：设计一个函数，确定随机数需要大量的内存和带宽，以至于这些内存不能被并行地去计算随机数。第二个方向是让计算变得更普遍化; 对于这个普遍化的计算，使得特殊硬件和普通的桌面计算机计算起来都差不多。在以太坊1.0中，我们选择了第一个方向。

PoW是工作量证明函数，这个函数根据数组做计算，这个数组中的第一个元素是混合哈希，第二个元素是依赖于区块头和需要计算混合哈希值的数据集合的加密伪随机数。这个算法称为Ethash。

**11.5.1** Ethash是以太坊1.0的PoW算法，它的概况如下：

通过扫描区块头得到一个种子。根据种子可以计算一个初始随机数缓存。轻节点客户端可以保存这个缓存。根据缓存，我们能生成一个初始化的数据集合，数据集合中每个元素依赖于缓存中的一小部分数据。全节点客户和矿工保存着数据集合。数据集合随时间线性增长。

挖矿涉及到组合数据集合的随机碎片并将他们哈希在一起。使用少量内存就可以验证，可以借助缓存重新产生需要的数据片段，所以仅需要保存缓存即可。大的数据集合每30000个区块更新一次，所以大多数矿工的工作都是读取这些数据集合，而不是尝试改变它。


